package fall2018.csc2017.slidingtiles;

import android.content.Context;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.NoSuchElementException;

import fall2018.csc2017.BoardManager;
import fall2018.csc2017.Move;
import fall2018.csc2017.Tile;

/**
 * Manage a board, including swapping tiles, checking for a win, and managing taps.
 */
class SlidingTilesBoardManager extends BoardManager {

    /**
     * Manage a new shuffled board with image tiles.
     *
     * @param size         size of the board
     * @param maxUndoMoves the maximum undos that the user can do
     * @param image the image to use as the background
     */
    SlidingTilesBoardManager(int size, int maxUndoMoves, byte[] image) {
        super(maxUndoMoves);
        setBoard(new SlidingTilesBoard(size, generateTiles(size), image));
    }

    /**
     * Helper method for generating all the sliding tiles for the board.
     *
     * @param size size of the board
     * @return the generated shuffled tiles
     */
    @Override
    public List<SlidingTile> generateTiles(int size) {
        List<SlidingTile> tiles = new ArrayList<>();
        int numTiles = (int) Math.pow(size, 2);
        for (int tileNum = 0; tileNum < numTiles; tileNum++) {
            tiles.add(new SlidingTile(tileNum));
        }

        // set the last tile to a blank tile
        tiles.get(tiles.size() - 1).setToBlankTile();

        SlidingTile t = tiles.remove(tiles.size() - 2);
        tiles.add(t);

        Collections.shuffle(tiles);
        makeSolvable(size, tiles);  // make sure the board is solvable
        return tiles;
    }


    /**
     * Change the tiles so that it is solvable if it isn't. Leave it alone otherwise.
     * source: wikipedia https://en.wikipedia.org/wiki/15_puzzle
     *
     * @param size  size of the board
     * @param tiles a list of tiles
     */
    private void makeSolvable(int size, List<SlidingTile> tiles) {
        int inv = 0;
        int rowDist = 0;
        for (int i = 0; i < tiles.size(); i++) {
            for (int j = i + 1; j < tiles.size(); j++) {
                if (tiles.get(j).getId() < tiles.get(i).getId()
                        && tiles.get(j).getId() != tiles.size() - 1
                        && tiles.get(i).getId() != tiles.size() - 1) {
                    inv++;
                }
            }
            if (tiles.get(i).getId() == tiles.size() - 1) {
                rowDist = size - 1 - i / size;
            }
        }
        if ((inv + rowDist) % 2 == 1) {
            Collections.swap(tiles, tiles.size() - 1, tiles.size() - 3);
        }
    }

    /**
     * Switch two tiles in the board
     *
     * @param m move to make
     */
    @Override
    public void gameMove(Move m) {
        SlidingTilesMove move = (SlidingTilesMove) m;
        int row1 = move.getRow1();
        int row2 = move.getRow2();
        int col1 = move.getCol1();
        int col2 = move.getCol2();

        Tile temp = getBoard().getTile(row1, col1);
        SlidingTilesBoard board = (SlidingTilesBoard) getBoard();

        board.setTile(row1, col1, getBoard().getTile(row2, col2));
        board.setTile(row2, col2, temp);
    }

    /**
     * Return whether the tiles are in row-major order.
     *
     * @return whether the tiles are in row-major order
     */
    @Override
    public boolean puzzleSolved() {
        boolean solved = true;

        Tile lastTile = null;
        for (Tile tile : getBoard()) {
            if (lastTile != null && lastTile.compareTo(tile) <= 0) {
                solved = false;
                break;
            }
            lastTile = tile;
        }
        return solved;
    }

    /**
     * Return whether any of the four surrounding tiles is the blank tile.
     *
     * @param m the move to check
     * @return whether the tile at position is surrounded by a blank tile
     */
    @Override
    public boolean isValidMove(Move m) {
        SlidingTilesMove move = (SlidingTilesMove) m;

        int row = move.getRow1();
        int col = move.getCol1();
        int blankId = ((SlidingTilesBoard) getBoard()).getBlankTileId();

        // Are any of the 4 the blank tile?
        Tile above = row == 0 ? null : getBoard().getTile(row - 1, col);
        Tile below = row == getBoard().getSize() - 1 ? null : getBoard().getTile(row + 1, col);
        Tile left = col == 0 ? null : getBoard().getTile(row, col - 1);
        Tile right = col == getBoard().getSize() - 1 ? null : getBoard().getTile(row, col + 1);
        return (below != null && below.getId() == blankId)
                || (above != null && above.getId() == blankId)
                || (left != null && left.getId() == blankId)
                || (right != null && right.getId() == blankId);
    }

    void undoClick(Context context) {
        try {
            if (!this.puzzleSolved()) {
                this.undoLastMove();
            }
        } catch (NoSuchElementException ex) {
            Toast.makeText(context, ex.getMessage(), Toast.LENGTH_SHORT).show();
        }
    }
}
